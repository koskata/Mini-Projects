#include <iostream>
#include <string>
#include <limits>
using namespace std;
int main()
{
    struct st {
        char s[5];
        int i;
    };

    typedef st* x;

    x P;
    st Z;

    P = new st;
    strcpy_s(P->s, "a12");
    P->i = 1;
    strcpy_s(Z.s, "b34");
    Z.i = 10;

    //cout << P; // грешка
    //cout << P->s[0]; // успешно = "а"
    //int A = P->i - Z.i; cout << A; // успешно = -9
    //x.i = "22"; cout << x // грешка защото x не може да бъде изпозлван за стойностите на st
}

//---------------Задача 2 - Списъци-------------------------------

int main()
{
    //2.2 Двусвързани списъци

    //a)
    // 
    //   |w|<=>|e|<=>|q|<=>|x|
    //1. P = Head->next->next->next;   => P=x
    //2. P->prev->info='?';            => третия елемент("q") става със стойност "?"

    // --> |w|<=>|e|<=>|?|<=>|x|

    
    //б)
    //     |w|<=>|e|<=>|?|<=>|x|
    // - Насочете указател Q към третия елемент на списъка;
    //      => Q = Head->next->next;
    // - В третия елемент на списъка запишете стойността на втори елемент;
    //      => Q->info = Q->prev->info

    // --> |w|<=>|e|<=>|e|<=>|x|


    //2.3 Дълга задача - 15т.
    //Даден е (не е необходимо да се разработва функция за създаване на списъка) едносвързан списък от низове с указател към първия елемент List.
    //Да се разработи функция за намиране на средно - аритметичната стойност на дължината на низовете.

    //#include <stdio.h>
    //#include <string.h>
    //
    //    typedef struct node {
    //        char info[100];
    //        struct node* next;
    //    } Node;

    //--------------

    /*float AvgLen(Node * List) {
        int sum = 0, count = 0;
        Node* p = List;
        while (p != NULL) {
            sum += strlen(p->info);
            count++;
            p = p->next;
        }
        if (count == 0) return 0;
        return (float)sum / count;
    }*/

    //--------------

    /*int main() {
        Node n3 = { "AI", NULL };
        Node n2 = { "hello", &n3 };
        Node n1 = { "cat", &n2 };
        Node* List = &n1;

        printf("Средна дължина на низовете: %.2f\n", AvgLen(List));
        return 0;
    }*/

}


int main()
{
    //3.1 Двоично дърво
    

    //Да се начертае дървото, получено в резултат на изпълнение на тази процедура при входен поток:
    //  1 2 - 5 6 - 7 - - - 3 - 8 - -

    //!!!!!! Първо наляво, после надясно

    //       1
    //      / \
    //    2     3
    //  /   \    \
    // -     5    8
    //      /
    //     6
    //    / \
    //   -   7


    // 3.2. Дърво на търсене

    // Да се начертае дърво по следния поток: 22, 26, 9, 6, 18, 23, 2, 20, 29

    // Първо имаме 22
    // После 26 > 22 => отива вдясно
    // После 9 < 22 => отива вляво
    // После 6 < 22 => отива вляво на 9
    //         < 9  
    // После 18 < 22 => отива вдясно на 9
    //          > 9
    // После 23 > 22 => отива вляво на 26
    //          < 26
    // После 2 < 22 => отива вляво на 6
    //         < 9
    //         < 6
    // После 20 < 22 => отива вдясно на 18
    //          > 9
    //          > 18
    // После 29 > 22 => отива вдясно на 26
    //          > 26

    //Решение \/

    //        22
    //      /    \
    //     9       26
    //    / \      / \
    //   6   18   23  29
    //  /      \
    // 2        20




    //3.3. 
    // 
    // !!!!!! ГЛЕДА СЕ НАЙ-ЛЯВОТО ДЕТЕ И АКО ИМА ДЕЦА(АКО НЕ ПРОСТО СЕ ЗАПИСВА ТО)(АКО ФУНКЦИЯТА ЗАПОЧВА ПЪРВО С ЛЯВОТО ДЕТЕ)
    // !!!! АКО ФУНКЦИЯТА print Е ПЪРВО С ДЯСНОТО ДЪРВО, ТОГАВА СЕ ГЛЕДА ПЪРВО КАКТО ДЯСНОТО ДЕТЕ, ТАКА И ДЯСНАТА МУ СТОЙНОСТ(ВСИЧКО ДЯСНО)
    // 
    // Приложете процедурата print, описана по-долу и посочете резултата от изпълнението ѝ върху дървото
    // void print(point P) {
    // if (P) {
    //    print(P->L);
    //    print(P->R);
    //    cout<<P->info<<' ';
    //    }
    // }

    // Първо се извиква лявото дъров "+"

    //     +
    //    / \
    //   *   "/"
    //  / \
    // 5   6

    /*

    1️⃣ print(*)

        print(5) → отпечатва 5

        print(6) → отпечатва 6

        после печата *
        👉 резултат : 5 6 *

        2️⃣ print(/ ) (дясното дете на + )
        → това / е листо(няма деца)
        👉 отпечатва /

        3️⃣ отпечатваме +

        ➡️ Лявото поддърво на корена дава :
    5 6 * / +
    
    */

    // После дясното дърво "/"

    //     /
    //    / \
    //   9   *
    //      / \
    //     3   1

    //1️⃣ print(9) → отпечатва 9
    //2️⃣ print(*)
    //print(3) → 3
    //print(1) → 1
    //после *
    //👉 резултат : 3 1 *
    //3️⃣ отпечатваме /
    //➡️ Дясното поддърво дава : 9 3 1 * /


    // => КРАЕН РЕЗУЛТАТ: 5 6 * / + 9 3 1 * / -
}
